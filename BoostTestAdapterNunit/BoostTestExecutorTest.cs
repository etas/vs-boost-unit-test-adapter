// (C) Copyright 2015 ETAS GmbH (http://www.etas.com/)
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using BoostTestAdapter;
using BoostTestAdapter.Boost.Runner;
using BoostTestAdapter.Settings;
using BoostTestAdapter.Utility;
using BoostTestAdapter.Utility.VisualStudio;
using BoostTestAdapterNunit.Fakes;
using BoostTestAdapterNunit.Utility;
using FakeItEasy;
using Microsoft.VisualStudio.TestPlatform.ObjectModel;
using Microsoft.VisualStudio.TestPlatform.ObjectModel.Adapter;
using NUnit.Framework;
using TimeoutException = BoostTestAdapter.Boost.Runner.TimeoutException;
using VSTestCase = Microsoft.VisualStudio.TestPlatform.ObjectModel.TestCase;
using VSTestResult = Microsoft.VisualStudio.TestPlatform.ObjectModel.TestResult;
using BoostTestAdapter.Utility.ExecutionContext;

namespace BoostTestAdapterNunit
{
    [TestFixture]
    class BoostTestExecutorTest
    {
        #region Test Setup/Teardown

        [SetUp]
        public void SetUp()
        {
            this.RunnerFactory = new StubBoostTestRunnerFactory(this);

            this.Executor = new BoostTestExecutor(
                this.RunnerFactory,
                new StubBoostTestDiscovererFactory(this),
                new DummyVSProvider
                (
                    new FakeVisualStudioInstanceBuilder()
                        .Solution
                        (
                            new FakeSolutionBuilder()        
                                .Project
                                (
                                    new FakeProjectBuilder()
                                        .PrimaryOutput(DefaultSource)
                                )
                        )
                    .Build()
                )
            );

            this.FrameworkHandle = new StubFrameworkHandle();

            this.RunContext = new DefaultTestContext();

            this.TestCaseProvider = GetTests;

            // By default, assume that tests pass
            this.TestResourceProvider = CreateDefaultResourceFactory(
                "BoostTestAdapterNunit.Resources.ReportsLogs.PassedTest.sample.test.log.xml",
                "BoostTestAdapterNunit.Resources.ReportsLogs.PassedTest.sample.test.report.xml"
            );
        }

        #endregion Test Setup/Teardown

        #region Test Data

        /// <summary>
        /// Test case fully qualified name which should generate a timeout exception.
        /// </summary>
        private const string TimeoutTestCase = "Timeout";

        /// <summary>
        /// Timeout threshold.
        /// </summary>
        private const int Timeout = 10;

        /// <summary>
        /// Default test case fully qualified name.
        /// </summary>
        private string DefaultTestCase
        {
            get
            {
                return "XmlDomInterfaceTestSuite/ParseXmlFileWithoutValidationTest";
            }
        }

        /// <summary>
        /// Fully qualified path to the default test source.
        /// </summary>
        private string DefaultSource
        {
            get
            {
                return "default";
            }
        }
        
        /// <summary>
        /// Empty test source fully qualified path.
        /// </summary>
        private string EmptySource
        {
            get
            {
                return "empty";
            }
        }

        private StubBoostTestRunnerFactory RunnerFactory { get; set; }
        private BoostTestExecutor Executor { get; set; }
        private StubFrameworkHandle FrameworkHandle { get; set; }
        private DefaultTestContext RunContext { get; set; }

        private class TestResources
        {
            public string LogFilePath { get; set; }
            public string ReportFilePath { get; set; }
            public string StdOutPath { get; set; }
            public string StdErrPath { get; set; }
        };

        // Provides (internal resource) paths to test output generated by the BOOST test framework
        private delegate TestResources TestResourceFactory(string source, string testcase);
        // Function which is executed by the MockBoostTestRunner in order to provide
        // sample template files to the execution framework
        private TestResourceFactory TestResourceProvider { get; set; }

        // Provides an enumeration of test cases for the provided BOOST test module
        private delegate IEnumerable<VSTestCase> TestCaseFactory(string source);
        // Function which is executed by the StubBoostTestDiscovererFactory in order to provide
        // sample test cases to the discovery framework
        private TestCaseFactory TestCaseProvider { get; set; }

        #endregion Test Data

        #region Stubs/Mocks

        /// <summary>
        /// Utility base class allowing access to the parent class.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        private abstract class InnerClass<T>
        {
            protected InnerClass(T parent)
            {
                this.Parent = parent;
            }

            /// <summary>
            /// Parent class hosting this inner class.
            /// </summary>
            protected T Parent { get; private set; }
        }

        /// <summary>
        /// Stub ITestDiscovererFactory implementation. Generates StubBoostTestDiscoverer instances.
        /// </summary>
        private class StubBoostTestDiscovererFactory : InnerClass<BoostTestExecutorTest>, IBoostTestDiscovererFactory
        {
            public StubBoostTestDiscovererFactory(BoostTestExecutorTest parent) :
                base(parent)
            {
            }

            #region ITestDiscovererFactory
            
            public IEnumerable<FactoryResult> GetDiscoverers(IReadOnlyCollection<string> sources, BoostTestAdapterSettings settings)
            {
                return new List<FactoryResult>()
                {
                    new FactoryResult()
                    {
                        Discoverer = new StubBoostTestDiscoverer(this.Parent),
                        Sources = sources
                    }
                };
            }

            #endregion ITestDiscovererFactory
        }

        /// <summary>
        /// Stub ITestDiscoverer implementation. Based on the requested source, generates fake discovery results.
        /// </summary>
        private class StubBoostTestDiscoverer : InnerClass<BoostTestExecutorTest>, IBoostTestDiscoverer
        {
            public StubBoostTestDiscoverer(BoostTestExecutorTest parent) :
                base(parent)
            {
            }

            #region ITestDiscoverer

            public void DiscoverTests(IEnumerable<string> sources, IDiscoveryContext discoveryContext, ITestCaseDiscoverySink discoverySink)
            {
                foreach (string source in sources)
                {
                    foreach (VSTestCase test in this.Parent.TestCaseProvider(source))
                    {
                        discoverySink.SendTestCase(test);
                    }
                }
            }

            #endregion ITestDiscoverer
        }

        /// <summary>
        /// Stub IBoostTestRunnerFactory implementation. Provisions fake IBoostTestRunner instances
        /// which simulate certain conditions based on the requested source.
        /// </summary>
        private class StubBoostTestRunnerFactory : InnerClass<BoostTestExecutorTest>, IBoostTestRunnerFactory
        {
            public StubBoostTestRunnerFactory(BoostTestExecutorTest parent) :
                base(parent)
            {
                this.ProvisionedRunners = new List<IBoostTestRunner>();
            }

            public IList<IBoostTestRunner> ProvisionedRunners { get; private set; }

            /// <summary>
            /// Reference to the latest IBoostTestRunner which was provisioned by this factory.
            /// </summary>
            public IBoostTestRunner LastTestRunner
            {
                get { return this.ProvisionedRunners.LastOrDefault(); }
            }

            #region IBoostTestRunnerFactory

            public IBoostTestRunner GetRunner(string identifier, BoostTestRunnerFactoryOptions options)
            {
                switch (identifier)
                {
                    case TimeoutTestCase:
                        {
                            IBoostTestRunner timeoutRunner = A.Fake<IBoostTestRunner>();
                            A.CallTo(() => timeoutRunner.Source).Returns(identifier);
                            A.CallTo(() => timeoutRunner.Execute(A<BoostTestRunnerCommandLineArgs>._, A<BoostTestRunnerSettings>._, A<IProcessExecutionContext>._)).Throws(new TimeoutException(Timeout));

                            return Provision(timeoutRunner);
                        }
                }

                return Provision(new MockBoostTestRunner(this.Parent, identifier));
            }

            #endregion IBoostTestRunnerFactory

            private IBoostTestRunner Provision(IBoostTestRunner runner)
            {
                this.ProvisionedRunners.Add(runner);
                return runner;
            }
        }

        public class MockBoostTestRunnerExecutionArgs
        {
            public BoostTestRunnerCommandLineArgs Arguments { get; set; }
            public BoostTestRunnerSettings Settings { get; set; }
            public IProcessExecutionContext Context { get; set; }
        }

        /// <summary>
        /// Mock IBoostTestRunner implementation.
        /// 
        /// - Provides access to the latest call information for post-request checking.
        /// - Allows for mocking test results by using temporary files which can be accessed by the rest of the system.
        /// </summary>
        private class MockBoostTestRunner : InnerClass<BoostTestExecutorTest>, IBoostTestRunner
        {
            #region Constructors

            public MockBoostTestRunner(BoostTestExecutorTest parent, string source) :
                base(parent)
            {
                this.Source = source;
                this.ExecutionArgs = new List<MockBoostTestRunnerExecutionArgs>();
            }

            #endregion Constructors

            #region Properties

            public IList<MockBoostTestRunnerExecutionArgs> ExecutionArgs { get; private set; }

            public int RunCount
            {
                get { return this.ExecutionArgs.Count; }
            }

            #endregion Properties

            #region IBoostTestRunner
            
            public int Execute(BoostTestRunnerCommandLineArgs args, BoostTestRunnerSettings settings, IProcessExecutionContext context)
            {
                this.ExecutionArgs.Add(new MockBoostTestRunnerExecutionArgs()
                {
                    Arguments = args,
                    Settings = settings,
                    Context = context
                });

                Assert.That(args.ReportFile, Is.Not.Null);
                Assert.That(args.ReportFormat, Is.EqualTo(OutputFormat.XML));

                Assert.That(args.LogFile, Is.Not.Null);
                Assert.That(args.LogFormat, Is.EqualTo(OutputFormat.XML));

                string temp = Path.GetDirectoryName(Path.GetTempPath());

                Assert.That(Path.GetDirectoryName(args.ReportFile), Is.EqualTo(temp));
                Assert.That(Path.GetDirectoryName(args.LogFile), Is.EqualTo(temp));

                if (!string.IsNullOrEmpty(args.StandardOutFile))
                {
                    Assert.That(Path.GetDirectoryName(args.StandardOutFile), Is.EqualTo(temp));
                }

                if (!string.IsNullOrEmpty(args.StandardErrorFile))
                {
                    Assert.That(Path.GetDirectoryName(args.StandardErrorFile), Is.EqualTo(temp));
                }
                
                // Copy the default result files to a temporary location so that they can eventually be read as a test result collection

                foreach (string test in args.Tests)
                {
                    TestResources resources = Parent.TestResourceProvider(this.Source, test);

                    if (!string.IsNullOrEmpty(resources.ReportFilePath))
                    {
                        Copy(resources.ReportFilePath, args.ReportFile);
                    }

                    if (!string.IsNullOrEmpty(resources.LogFilePath))
                    {
                        Copy(resources.LogFilePath, args.LogFile);
                    }
                    
                    if (!string.IsNullOrEmpty(args.StandardOutFile) && !string.IsNullOrEmpty(resources.StdOutPath))
                    {
                        Copy(resources.StdOutPath, args.StandardOutFile);
                    }
                    
                    if (!string.IsNullOrEmpty(args.StandardErrorFile) && !string.IsNullOrEmpty(resources.StdErrPath))
                    {
                        Copy(resources.StdErrPath, args.StandardErrorFile);
                    }
                }

                return 0;
            }

            public string Source { get; private set; }

            public IBoostTestRunnerCapabilities Capabilities { get; } = new BoostTestRunnerCapabilities { ListContent = false, Version = false };

            #endregion IBoostTestRunner

            private void Copy(string embeddedResource, string path)
            {
                using (Stream inStream = TestHelper.LoadEmbeddedResource(embeddedResource))
                using (FileStream outStream = File.Create(path))
                {
                    inStream.CopyTo(outStream);
                }
            }
        }

        /// <summary>
        /// Stub IFrameworkHandle implementation. Allows access to recorded TestResults.
        /// </summary>
        private class StubFrameworkHandle : ConsoleMessageLogger, IFrameworkHandle
        {
            public StubFrameworkHandle()
            {
                this.Results = new List<VSTestResult>();
            }

            public ICollection<VSTestResult> Results { get; private set; }

            #region IFrameworkHandle

            public bool EnableShutdownAfterTestRun
            {
                get
                {
                    throw new NotImplementedException();
                }
                set
                {
                    throw new NotImplementedException();
                }
            }

            public int LaunchProcessWithDebuggerAttached(string filePath, string workingDirectory, string arguments, IDictionary<string, string> environmentVariables)
            {
                throw new NotImplementedException();
            }

            #endregion IFrameworkHandle

            #region ITestExecutionRecorder

            public void RecordAttachments(IList<AttachmentSet> attachmentSets)
            {
                throw new NotImplementedException();
            }

            public void RecordEnd(VSTestCase testCase, TestOutcome outcome)
            {
                throw new NotImplementedException();
            }

            public void RecordResult(VSTestResult testResult)
            {
                this.Results.Add(testResult);
            }

            public void RecordStart(VSTestCase testCase)
            {
                throw new NotImplementedException();
            }

            #endregion ITestExecutionRecorder
        }

        #endregion Stubs/Mocks

        #region Helper Methods

        /// <summary>
        /// Factory function which returns an enumeration of tests based on the provided test source
        /// </summary>
        /// <param name="source">The test source</param>
        /// <returns>An enumeration of tests related to the requested source</returns>
        private IEnumerable<VSTestCase> GetTests(string source)
        {
            if (source == DefaultSource)
            {
                return GetDefaultTests();
            }

            return Enumerable.Empty<VSTestCase>();
        }

        /// <summary>
        /// Enumerates a sample collection of tests.
        /// </summary>
        /// <returns>An enumeration of sample test cases</returns>
        private IEnumerable<VSTestCase> GetDefaultTests()
        {
            VSTestCase test = CreateTestCase(
                DefaultTestCase,
                DefaultSource
            );

            return new VSTestCase[] { test };
        }

        /// <summary>
        /// Creates a Visual Studio TestCase based on the provided information
        /// </summary>
        /// <param name="fullyQualifiedName">The fully qualified name of the test case</param>
        /// <param name="source">The test case source</param>
        /// <returns>A Visual Studio TestCase intended for BoostTestExecutor execution</returns>
        private VSTestCase CreateTestCase(string fullyQualifiedName, string source)
        {
            VSTestCase test = new VSTestCase(fullyQualifiedName, BoostTestExecutor.ExecutorUri, source);

            var fullyQualifiedNameBuilder = QualifiedNameBuilder.FromString(fullyQualifiedName);

            test.DisplayName = fullyQualifiedNameBuilder.Peek();

            test.Traits.Add(VSTestModel.TestSuiteTrait, fullyQualifiedNameBuilder.Pop().ToString());
            test.Traits.Add(VSTestModel.StatusTrait, VSTestModel.TestEnabled);

            return test;
        }
        private VSTestCase CreateTestCase(string fullyQualifiedName, string source, bool Enabled)
        {
            VSTestCase test = new VSTestCase(fullyQualifiedName, BoostTestExecutor.ExecutorUri, source);

            test.Traits.Add(VSTestModel.TestSuiteTrait, QualifiedNameBuilder.FromString(fullyQualifiedName).Pop().ToString());
            if(Enabled)
            {
                test.Traits.Add(VSTestModel.StatusTrait, VSTestModel.TestEnabled);
            }
            else
            {
                test.Traits.Add(VSTestModel.StatusTrait, VSTestModel.TestDisabled);
            }

            return test;
        }

        private IEnumerable<VSTestCase> GenerateTestCases(IEnumerable<string> fullyQualifiedNames, string source)
        {
            foreach (string testCase in fullyQualifiedNames)
            {
                yield return CreateTestCase(testCase, source);
            }
        }

        /// <summary>
        /// Asserts test properties for the DefaultTestCase
        /// </summary>
        /// <param name="results"></param>
        private void AssertDefaultTestResultProperties(ICollection<VSTestResult> results)
        {
            Assert.That(this.FrameworkHandle.Results.Count(), Is.EqualTo(1));

            VSTestResult result = results.First();

            Assert.That(result.ComputerName, Is.EqualTo(Environment.MachineName));

            Assert.That(result.Outcome, Is.EqualTo(TestOutcome.Passed));

            Assert.That(result.TestCase.Source, Is.EqualTo(DefaultSource));
            Assert.That(result.TestCase.FullyQualifiedName, Is.EqualTo(DefaultTestCase));
        }

        private static TestResourceFactory CreateDefaultResourceFactory(string logFile, string reportFile)
        {
            return CreateDefaultResourceFactory(
                logFile,
                reportFile,
                "BoostTestAdapterNunit.Resources.ReportsLogs.Empty.sample.test.stdout.log",
                "BoostTestAdapterNunit.Resources.ReportsLogs.Empty.sample.test.stderr.log"
            );
        }

        private static TestResourceFactory CreateDefaultResourceFactory(string logFile, string reportFile, string stdOutFile, string stdErrFile)
        {
            return (string source, string testcase) =>
            {
                return new TestResources()
                {
                    LogFilePath = logFile,
                    ReportFilePath = reportFile,
                    StdOutPath = stdOutFile,
                    StdErrPath = stdErrFile,
                };
            };
        }

        #endregion Helper Methods

        #region Tests

        /// <summary>
        /// Test execution via the 'Run All' command.
        /// 
        /// Test aims:
        ///     - Ensure that all tests within a source are executed and reported.
        /// </summary>
        [Test]
        public void RunTestsFromSource()
        {
            this.Executor.RunTests(
                new string[] { DefaultSource },
                this.RunContext,
                this.FrameworkHandle
            );

            AssertDefaultTestResultProperties(this.FrameworkHandle.Results);

            MockBoostTestRunner runner = this.RunnerFactory.LastTestRunner as MockBoostTestRunner;

            Assert.That(runner, Is.Not.Null);
            Assert.That(runner.ExecutionArgs.All(args => (!args.Arguments.CatchSystemErrors.HasValue || args.Arguments.CatchSystemErrors.Value)), Is.True);
        }

        /// <summary>
        /// A 'Run All' command on an empty source does not fail.
        /// 
        /// Test aims:
        ///     - Ensure that a request for running no tests operates correctly.
        /// </summary>
        [Test]
        public void RunTestsFromEmptySource()
        {
            this.Executor.RunTests(
                new string[] { EmptySource },
                this.RunContext,
                this.FrameworkHandle
            );

            Assert.That(this.FrameworkHandle.Results.Count(), Is.EqualTo(0));
        }

        /// <summary>
        /// A selection of tests can be executed.
        /// 
        /// Test aims:
        ///     - Ensure that when users select a test selection, only those tests are executed.
        /// </summary>
        [Test]
        public void RunTestSelection()
        {
            this.Executor.RunTests(
                GetDefaultTests(),
                this.RunContext,
                this.FrameworkHandle
            );

            AssertDefaultTestResultProperties(this.FrameworkHandle.Results);

            MockBoostTestRunner runner = this.RunnerFactory.LastTestRunner as MockBoostTestRunner;

            Assert.That(runner, Is.Not.Null);
            Assert.That(runner.ExecutionArgs.All(args => (!args.Arguments.CatchSystemErrors.HasValue || args.Arguments.CatchSystemErrors.Value)), Is.True);
        }

        /// <summary>
        /// Debug test runs are available when selecting 'Debug Tests' for a test selection from the test adapter.
        /// 
        /// Test aims:
        ///     - Ensure that when users select to perform a debug test run, a debug run is actually performed.
        /// </summary>
        [Test]
        public void DebugTestSelection()
        {
            this.RunContext.IsBeingDebugged = true;

            this.Executor.RunTests(
                GetDefaultTests(),
                this.RunContext,
                this.FrameworkHandle
            );

            MockBoostTestRunner runner = this.RunnerFactory.LastTestRunner as MockBoostTestRunner;

            Assert.That(runner, Is.Not.Null);
            Assert.That(runner.ExecutionArgs.First().Context, Is.TypeOf<DebugFrameworkExecutionContext>());
            Assert.That(runner.ExecutionArgs.All(args => (args.Arguments.CatchSystemErrors.HasValue && !args.Arguments.CatchSystemErrors.Value)), Is.True);

            AssertDefaultTestResultProperties(this.FrameworkHandle.Results);
        }

        /// <summary>
        /// "BUTA" environment variable should be set within an execution context.
        /// 
        /// Test aims:
        ///     - Ensure that the text execution runner provides the environment variable "BUTA" in the execution
        ///     context
        /// </summary>
        [Test]
        public void BUTAEnvironmentVariableProvided()
        {
            this.RunContext.IsBeingDebugged = true;

            this.Executor.RunTests(
                GetDefaultTests(),
                this.RunContext,
                this.FrameworkHandle
            );

            MockBoostTestRunner runner = this.RunnerFactory.LastTestRunner as MockBoostTestRunner;

            Assert.That(runner, Is.Not.Null);

            var oExpectedEnvironmentVariables = new Dictionary<string, string>()
            {
                { "BUTA", "1" }
            };

            CollectionAssert.AreEqual(oExpectedEnvironmentVariables, runner.ExecutionArgs.First().Arguments.Environment);

        }

        /// <summary>
        /// Given a valid .runsettings, test execution should respect the configuration.
        /// 
        /// Test aims:
        ///     - Ensure that test execution is able to interpret valid .runsettings.
        /// </summary>
        [Test]
        public void RunTestsWithTestSettings()
        {
            this.RunContext.RegisterSettingProvider(BoostTestAdapterSettings.XmlRootName, new BoostTestAdapterSettingsProvider());
            this.RunContext.LoadEmbeddedSettings("BoostTestAdapterNunit.Resources.Settings.sample.runsettings");

            this.Executor.RunTests(
                GetDefaultTests(),
                this.RunContext,
                this.FrameworkHandle
            );

            AssertDefaultTestResultProperties(this.FrameworkHandle.Results);

            MockBoostTestRunner runner = this.RunnerFactory.LastTestRunner as MockBoostTestRunner;

            Assert.That(runner, Is.Not.Null);

            Assert.That(runner.RunCount, Is.EqualTo(1));
            Assert.That(runner.ExecutionArgs.First().Settings.Timeout, Is.EqualTo(600000));
        }

        /// <summary>
        /// Given a test fully-qualified names which contain characters which are not compatible with the Boost Test
        /// command-line, generate a 'test not found' notification to the user.
        /// 
        /// Test aims:
        ///     - Ensure that tests which cannot be individually referenced from Boost Test command line are identified
        ///       and marked as skipped.
        /// </summary>
        [Test]
        public void TestSkipEdgeCases()
        {
            const string logFile = "BoostTestAdapterNunit.Resources.ReportsLogs.NoMatchingTests.sample.test.log.xml";
            const string reportFile = "BoostTestAdapterNunit.Resources.ReportsLogs.NoMatchingTests.sample.test.report.xml";

            this.TestResourceProvider = CreateDefaultResourceFactory(logFile, reportFile);

            this.Executor.RunTests(
                new VSTestCase[] {
                    CreateTestCase("my_test<unsigned char>", DefaultSource),
                    CreateTestCase("boost::bind(my_other_test,3)", DefaultSource)
                },
                this.RunContext,
                this.FrameworkHandle
            );

            Assert.That(this.FrameworkHandle.Results.Count(), Is.EqualTo(2));

            foreach (VSTestResult result in this.FrameworkHandle.Results)
            {
                Assert.That(result.Outcome, Is.EqualTo(TestOutcome.Skipped));
            }
        }

        /// <summary>
        /// Given a long running test, test execution should stop after a pre-determined timeout threshold and inform the user accordingly.
        /// 
        /// Test aims:
        ///     - Ensure that with proper configuration, long running tests generate a timeout test failure.
        /// </summary>
        [Test]
        public void TestTimeoutException()
        {
            this.Executor.RunTests(
                new VSTestCase[] { CreateTestCase("test", TimeoutTestCase) },
                this.RunContext,
                this.FrameworkHandle
            );

            Assert.That(this.FrameworkHandle.Results.Count(), Is.EqualTo(1));

            VSTestResult result = this.FrameworkHandle.Results.First();

            Assert.That(result.Outcome, Is.EqualTo(TestOutcome.Failed));
            Assert.That(result.Duration, Is.EqualTo(TimeSpan.FromMilliseconds(Timeout)));
            Assert.That(result.ErrorMessage.ToLowerInvariant().Contains("timeout"), Is.True);
        }

        /// <summary>
        /// Given a test module which throws an exception in the global fixture, all tests should report the global fixture exception.
        /// 
        /// Test aims:
        ///     - Ensure that a failing global fixture error is reported accordingly.
        /// </summary>
        [Test]
        public void TestGlobalFixtureException()
        {
            const string logFile = "BoostTestAdapterNunit.Resources.ReportsLogs.GlobalFixtureError.sample.test.log.xml";
            const string reportFile = "BoostTestAdapterNunit.Resources.ReportsLogs.GlobalFixtureError.sample.test.report.xml";

            this.TestResourceProvider = CreateDefaultResourceFactory(logFile, reportFile);
            
            this.Executor.RunTests(
                new VSTestCase[] { CreateTestCase("Test1", DefaultSource), CreateTestCase("Test2", DefaultSource) },
                this.RunContext,
                this.FrameworkHandle
            );

            // Ensure that a single MockBoostTestRunner was provisioned
            Assert.That(this.RunnerFactory.ProvisionedRunners.Count, Is.EqualTo(1));
            MockBoostTestRunner runner = this.RunnerFactory.LastTestRunner as MockBoostTestRunner;
            Assert.That(runner, Is.Not.Null);

            // Ensure that the tests are marked as failed and that the content of the message is equivalent to that of the report
            string reportContent = TestHelper.ReadEmbeddedResource(reportFile);

            Assert.That(this.FrameworkHandle.Results.Count(), Is.EqualTo(2));
            foreach (VSTestResult result in this.FrameworkHandle.Results)
            {
                Assert.That(result.ComputerName, Is.EqualTo(Environment.MachineName));
                Assert.That(result.TestCase.Source, Is.EqualTo(DefaultSource));
                Assert.That(result.Outcome, Is.EqualTo(TestOutcome.Failed));

                Assert.That(result.ErrorMessage, Is.EqualTo(reportContent));
            }
        }

        /// <summary>
        /// Given a test module which is executed but the report file is empty, tests should be reported as failed.
        /// 
        /// Test aims:
        ///     - Ensure that failing to acquire a report implies a failed test case.
        /// </summary>
        [Test]
        public void TestEmptyBoostReport()
        {
            const string logFile = "BoostTestAdapterNunit.Resources.ReportsLogs.Empty.sample.test.log.xml";
            const string reportFile = "BoostTestAdapterNunit.Resources.ReportsLogs.Empty.sample.test.report.xml";

            this.TestResourceProvider = CreateDefaultResourceFactory(logFile, reportFile);

            this.Executor.RunTests(
                new string[] { DefaultSource },
                this.RunContext,
                this.FrameworkHandle
            );

            // Ensure that a single MockBoostTestRunner was provisioned
            Assert.That(this.RunnerFactory.ProvisionedRunners.Count, Is.EqualTo(1));
            MockBoostTestRunner runner = this.RunnerFactory.LastTestRunner as MockBoostTestRunner;
            Assert.That(runner, Is.Not.Null);

            // Ensure that the tests are marked as failed due to empty report file
            Assert.That(this.FrameworkHandle.Results.Count(), Is.EqualTo(1));
            foreach (VSTestResult result in this.FrameworkHandle.Results)
            {
                Assert.That(result.ComputerName, Is.EqualTo(Environment.MachineName));
                Assert.That(result.TestCase.Source, Is.EqualTo(DefaultSource));
                Assert.That(result.Outcome, Is.EqualTo(TestOutcome.Failed));
            }
        }

        /// <summary>
        /// Given a request for code coverage on all tests, tests should execute as usual, possibly in an optimized manner.
        /// 
        /// Test aims:
        ///     - Ensure that it is possible to run code coverage on a tests of a particular source.
        /// </summary>
        [Test]
        public void TestCodeCoverage()
        {
            this.RunContext.IsDataCollectionEnabled = true;

            this.Executor.RunTests(
                new string[] { DefaultSource },
                this.RunContext,
                this.FrameworkHandle
            );

            IList<MockBoostTestRunner> runners = this.RunnerFactory.ProvisionedRunners.OfType<MockBoostTestRunner>().ToList();

            // Although multiple runners (one per testcase) will be provisioned, only one type of runner (specific to DefaultSource) is used
            Assert.That(runners.GroupBy(runner => runner.Source).Count(), Is.EqualTo(1));

            // Only one runner is executed and that runner is only executed once 
            MockBoostTestRunner testRunner = runners.FirstOrDefault(runner => runner.RunCount == 1);

            Assert.That(testRunner, Is.Not.Null);

            // All tests are executed
            Assert.That(testRunner.ExecutionArgs.First().Arguments.Tests, Is.Empty);
        }

        /// <summary>
        /// Given a request for code coverage on selected tests, tests should execute as usual, possibly in an optimized manner.
        /// 
        /// Test aims:
        ///     - Ensure that it is possible to run code coverage on a selection of tests.
        /// </summary>
        [Test]
        public void TestCodeCoverageSelection()
        {
            this.RunContext.IsDataCollectionEnabled = true;

            this.Executor.RunTests(
                new VSTestCase[] { CreateTestCase("Test1", DefaultSource), CreateTestCase("Test2", DefaultSource) },
                this.RunContext,
                this.FrameworkHandle
            );

            IList<MockBoostTestRunner> runners = this.RunnerFactory.ProvisionedRunners.OfType<MockBoostTestRunner>().ToList();

            Assert.That(runners.GroupBy(runner => runner.Source).Count(), Is.EqualTo(1));

            MockBoostTestRunner testRunner = runners.FirstOrDefault(runner => runner.RunCount == 1);

            Assert.That(testRunner, Is.Not.Null);

            // All selected tests are executed
            Assert.That(testRunner.ExecutionArgs.First().Arguments.Tests.Count, Is.EqualTo(2));
        }

        /// <summary>
        /// Given a .runsettings which has 'BatchTestRuns' as false (or left unspecified), tests should individually, one process invocation per test case.
        /// 
        /// Test aims:
        ///     - Ensure that test modules are executed individually if 'BatchTestRuns' is set to false
        /// </summary>
        [Test]
        public void TestIndividualTestExecutionRuns()
        {
            this.RunContext.RegisterSettingProvider(BoostTestAdapterSettings.XmlRootName, new BoostTestAdapterSettingsProvider());
            this.RunContext.LoadSettings("<RunSettings><BoostTest><BatchTestRuns>false</BatchTestRuns></BoostTest></RunSettings>");

            VSTestCase[] testCases = new VSTestCase[]
            {
                CreateTestCase("A/1", DefaultSource), CreateTestCase("A/2", DefaultSource),
                CreateTestCase("B/1", DefaultSource)
            };

            this.Executor.RunTests(
                testCases,
                this.RunContext,
                this.FrameworkHandle
            );

            List<string> testIdentifiers = testCases.Select(test => test.FullyQualifiedName).ToList();

            foreach (IBoostTestRunner runner in this.RunnerFactory.ProvisionedRunners)
            {
                Assert.That(runner, Is.TypeOf<MockBoostTestRunner>());
                MockBoostTestRunner testRunner = (MockBoostTestRunner)runner;

                // TestRunners may be provisioned but left unused. We are only interested in the ones used to execute tests.
                if (testRunner.RunCount == 0)
                {
                    continue;
                }
                
                Assert.That(runner.Source, Is.EqualTo(DefaultSource));

                foreach (var args in testRunner.ExecutionArgs)
                {
                    // One test at a time should be invoked
                    Assert.That(args.Arguments.Tests.Count, Is.EqualTo(1));
                    Assert.That(testIdentifiers.Remove(args.Arguments.Tests[0]), Is.True);
                }
            }

            // All tests should be have been invoked
            Assert.That(testIdentifiers, Is.Empty);
        }

        /// <summary>
        /// Given a .runsettings which specifies 'BatchTestRuns', tests should execute as usual but in the least amount of processed runs.
        /// 
        /// Test aims:
        ///     - Ensure that test modules are executed once if 'BatchTestRuns' is true and 'Run All...' is triggered
        /// </summary>
        [Test]
        public void TestModuleBatchedRuns()
        {
            this.RunContext.RegisterSettingProvider(BoostTestAdapterSettings.XmlRootName, new BoostTestAdapterSettingsProvider());
            this.RunContext.LoadSettings("<RunSettings><BoostTest><TestBatchStrategy>Source</TestBatchStrategy></BoostTest></RunSettings>");

            string OtherSource = "OtherSource";
            string YetAnotherSource = "YetAnotherSource";
            
            List<string> sources = new List<string> { DefaultSource, OtherSource, YetAnotherSource };

            this.TestCaseProvider = (string source) =>
            {
                IEnumerable<VSTestCase> tests = GetTests(source);

                if (!tests.Any())
                {
                    if (source == OtherSource)
                    {
                        // 10 tests in 2 suites
                        List<string> fullyQualifiedNames = new List<string> {
                             "Suite1/Test1", "Suite1/Test2" , "Suite1/Test3" , "Suite1/Test4" , "Suite1/Test5"
                            ,"Suite2/Test1", "Suite2/Test2" , "Suite2/Test3" , "Suite2/Test4" , "Suite2/Test5"
                        };

                        return GenerateTestCases(fullyQualifiedNames, OtherSource);
                    }

                    if (source == YetAnotherSource)
                    {
                        // 5 tests in 2 suites
                        List<string> fullyQualifiedNames = new List<string> {
                             "Suite1/Test1", "Suite1/Test2" , "Suite1/Test3" , "Suite2/Test1" , "Suite2/Test2"
                        };

                        return GenerateTestCases(fullyQualifiedNames, YetAnotherSource);
                    }
                }

                return tests;
            };
            
            this.Executor.RunTests(
                sources,
                this.RunContext,
                this.FrameworkHandle
            );

            // One runner per source be provisioned for the available source
            foreach (IBoostTestRunner runner in this.RunnerFactory.ProvisionedRunners)
            {
                Assert.That(runner, Is.TypeOf<MockBoostTestRunner>());
                MockBoostTestRunner testRunner = (MockBoostTestRunner)runner;
                
                // 1 Module/Source -> 1 Execution for all contained tests within
                Assert.That(testRunner.RunCount, Is.EqualTo(1));

                Assert.That(sources.Remove(runner.Source), Is.True);

                // No tests should be specified on the command line implying all tests are to be executed
                Assert.That(testRunner.ExecutionArgs.First().Arguments.Tests.Count, Is.EqualTo(0));
            }

            Assert.That(sources, Is.Empty);
        }

        /// <summary>
        /// Given a .runsettings which specifies 'TestBatchStrategy', test suites should execute in one go rather than having each individual test executed on its own.
        /// 
        /// Test aims:
        ///     - Ensure that test suites are executed in groups if 'TestBatchStrategy' is TestSuite
        /// </summary>
        [Test]
        public void TestTestSuiteBatchedRuns()
        {
            this.RunContext.RegisterSettingProvider(BoostTestAdapterSettings.XmlRootName, new BoostTestAdapterSettingsProvider());
            this.RunContext.LoadSettings("<RunSettings><BoostTest><TestBatchStrategy>TestSuite</TestBatchStrategy></BoostTest></RunSettings>");

            string otherSource = "OtherSource";

            this.Executor.RunTests(
                new VSTestCase[] { CreateTestCase("A/Test1", DefaultSource), CreateTestCase("A/Test2", DefaultSource), CreateTestCase("B/Test1", DefaultSource), CreateTestCase("A/Test1", otherSource) },
                this.RunContext,
                this.FrameworkHandle
            );
            
            List<KeyValuePair<string, IList<string>>> expectedBatches = new List<KeyValuePair<string, IList<string>>>
            {
                new KeyValuePair<string, IList<string>>(DefaultSource, new List<string> {"A/Test1", "Test2"}),
                new KeyValuePair<string, IList<string>>(DefaultSource, new List<string> {"B/Test1"}),
                new KeyValuePair<string, IList<string>>(otherSource, new List<string> {"A/Test1"})
            };

            // A runner per test suite per module should be provisioned
            foreach (IBoostTestRunner runner in this.RunnerFactory.ProvisionedRunners)
            {
                Assert.That(runner, Is.TypeOf<MockBoostTestRunner>());
                MockBoostTestRunner testRunner = (MockBoostTestRunner)runner;

                for (int i = 0; i < testRunner.RunCount; ++i)
                {
                    KeyValuePair<string, IList<string>> run = new KeyValuePair<string, IList<string>>(testRunner.Source, testRunner.ExecutionArgs[i].Arguments.Tests);
                    Assert.That(expectedBatches.RemoveAll(batch => (batch.Key == testRunner.Source) && (!batch.Value.Except(testRunner.ExecutionArgs[i].Arguments.Tests).Any())), Is.EqualTo(1));
                }
            }

            Assert.That(expectedBatches, Is.Empty);
        }


        /// <summary>
        /// Given a scenario where disabled tests should not run when pressing "Run all..." they should be skipped
        /// 
        /// Test aims:
        ///     - Ensure that test cases that are disabled are not run when "Run all..." is pressed
        /// </summary>
        [Test]
        public void TestDisabledTestsRunAll()
        {
            this.RunContext.RegisterSettingProvider(BoostTestAdapterSettings.XmlRootName, new BoostTestAdapterSettingsProvider());
            this.RunContext.LoadSettings("<RunSettings><BoostTest><RunDisabledTests>false</RunDisabledTests></BoostTest></RunSettings>");

            string MySource = "MySource";


            this.TestCaseProvider = (string source) =>
            {
                VSTestCase[] testCases = new VSTestCase[]
                {
                    CreateTestCase("A/1", MySource, false), CreateTestCase("A/2", MySource),
                    CreateTestCase("B/1", MySource), CreateTestCase("B/2", MySource, false), CreateTestCase("B/3", MySource, false)
                };
                return testCases;
            };

            this.Executor.RunTests(
               new string[] { MySource },
                this.RunContext,
                this.FrameworkHandle
            );

           
            foreach (IBoostTestRunner runner in this.RunnerFactory.ProvisionedRunners)
            {
                // One runner per source is provisioned for the available source
                Assert.That(this.RunnerFactory.ProvisionedRunners.Count, Is.EqualTo(1));

                Assert.That(runner, Is.TypeOf<MockBoostTestRunner>());
                MockBoostTestRunner testRunner = (MockBoostTestRunner)runner;

                //Ensure that the source is that specified
                Assert.That(testRunner.Source, Is.EqualTo(MySource));

                // The same runner is run for every test that will be executed, in this case 2
                Assert.That(testRunner.RunCount, Is.EqualTo(2));

                // Check that only the enabled tests are run
                Assert.That(testRunner.ExecutionArgs[0].Arguments.Tests[0], Is.EqualTo("A/2"));
                Assert.That(testRunner.ExecutionArgs[1].Arguments.Tests[0], Is.EqualTo("B/1"));
            }

        }

        /// <summary>
        /// When pressing "Run all...", if given a .runsettings file where RunDisabledTests is set to True, all tests should be executed
        /// 
        /// Test aims:
        ///     - Ensure that test cases that are disabled are run when "Run all..." is pressed
        /// </summary>
        [Test]
        public void TestDisabledTestsRunAllSettings()
        {
            this.RunContext.RegisterSettingProvider(BoostTestAdapterSettings.XmlRootName, new BoostTestAdapterSettingsProvider());
            this.RunContext.LoadSettings("<RunSettings><BoostTest><RunDisabledTests>true</RunDisabledTests></BoostTest></RunSettings>");

            string MySource = "MySource";


            this.TestCaseProvider = (string source) =>
            {
                VSTestCase[] testCases = new VSTestCase[]
                {
                    CreateTestCase("A/1", MySource, false), CreateTestCase("A/2", MySource),
                    CreateTestCase("B/1", MySource), CreateTestCase("B/2", MySource, false), CreateTestCase("B/3", MySource, false)
                };
                return testCases;
            };

            this.Executor.RunTests(
               new string[] { MySource },
                this.RunContext,
                this.FrameworkHandle
            );


            foreach (IBoostTestRunner runner in this.RunnerFactory.ProvisionedRunners)
            {
                // One runner per source is provisioned for the available source
                Assert.That(this.RunnerFactory.ProvisionedRunners.Count, Is.EqualTo(1));

                Assert.That(runner, Is.TypeOf<MockBoostTestRunner>());
                MockBoostTestRunner testRunner = (MockBoostTestRunner)runner;

                //Ensure that the source is that specified
                Assert.That(testRunner.Source, Is.EqualTo(MySource));

                // The same runner is run for every test that will be executed, in this case 5
                Assert.That(testRunner.RunCount, Is.EqualTo(5));

                // Check that only the enabled tests are run
                Assert.That(testRunner.ExecutionArgs[0].Arguments.Tests[0], Is.EqualTo("A/1"));
                Assert.That(testRunner.ExecutionArgs[1].Arguments.Tests[0], Is.EqualTo("A/2"));
                Assert.That(testRunner.ExecutionArgs[2].Arguments.Tests[0], Is.EqualTo("B/1"));
                Assert.That(testRunner.ExecutionArgs[3].Arguments.Tests[0], Is.EqualTo("B/2"));
                Assert.That(testRunner.ExecutionArgs[4].Arguments.Tests[0], Is.EqualTo("B/3"));
            }

        }



        /// <summary>
        /// When running selected tests, all tests should run, regardless of whether they were disabled or not
        /// 
        /// Test aims:
        ///     - Ensure that test cases that are disabled are run when specifically selected
        /// </summary>
        [Test]
        public void TestDisabledTestsRunSelectedTest()
        {
            this.RunContext.RegisterSettingProvider(BoostTestAdapterSettings.XmlRootName, new BoostTestAdapterSettingsProvider());

            string MySource = "MySource";

            this.Executor.RunTests(
                 new VSTestCase[] { CreateTestCase("A/1", MySource, false), CreateTestCase("A/2", MySource) },
                 this.RunContext,
                 this.FrameworkHandle
             );


            foreach (IBoostTestRunner runner in this.RunnerFactory.ProvisionedRunners)
            {
                // One runner per source is provisioned for the available source
                Assert.That(this.RunnerFactory.ProvisionedRunners.Count, Is.EqualTo(1));

                Assert.That(runner, Is.TypeOf<MockBoostTestRunner>());
                MockBoostTestRunner testRunner = (MockBoostTestRunner)runner;

                //Ensure that the source is that specified
                Assert.That(testRunner.Source, Is.EqualTo(MySource));

                // The same runner is run for every test that will be executed, in this case 2
                Assert.That(testRunner.RunCount, Is.EqualTo(2));

                // Check that both tests are run, since both were selected
                Assert.That(testRunner.ExecutionArgs[0].Arguments.Tests[0], Is.EqualTo("A/1"));
                Assert.That(testRunner.ExecutionArgs[1].Arguments.Tests[0], Is.EqualTo("A/2"));
            }

        }

        /// <summary>
        /// Given a .runsettings which specifies that standard output and standard error should not be redirected, the executor should respect such settings.
        /// 
        /// Test aims:
        ///     - Ensure that EnableStdOutRedirection and EnableStdErrRedirection configuration elements are respected.
        /// </summary>
        [Test]
        public void DisableStdOutErrRedirection()
        {
            this.RunContext.RegisterSettingProvider(BoostTestAdapterSettings.XmlRootName, new BoostTestAdapterSettingsProvider());
            this.RunContext.LoadSettings("<RunSettings><BoostTest><EnableStdOutRedirection>false</EnableStdOutRedirection><EnableStdErrRedirection>false</EnableStdErrRedirection></BoostTest></RunSettings>");

            this.Executor.RunTests(
                new string[] { DefaultSource },
                this.RunContext,
                this.FrameworkHandle
            );

            AssertDefaultTestResultProperties(this.FrameworkHandle.Results);

            foreach (IBoostTestRunner runner in this.RunnerFactory.ProvisionedRunners)
            {
                Assert.That(runner, Is.TypeOf<MockBoostTestRunner>());
                MockBoostTestRunner testRunner = (MockBoostTestRunner) runner;

                foreach (var args in testRunner.ExecutionArgs)
                {
                    Assert.That(args.Arguments.StandardOutFile, Is.Null);
                    Assert.That(args.Arguments.StandardErrorFile, Is.Null);
                }
            }
        }

        /// <summary>
        /// Assert that: Failing to execute a test due to an adapter error, the test should be explicitly marked
        /// </summary>
        [Test]
        public void ExecutionException()
        {
            IBoostTestRunner runner = A.Fake<IBoostTestRunner>();
            A.CallTo(() => runner.Source).Returns(DefaultSource);
            A.CallTo(() => runner.Execute(A<BoostTestRunnerCommandLineArgs>._, A<BoostTestRunnerSettings>._, A<IProcessExecutionContext>._)).Throws(new Exception());

            IBoostTestRunnerFactory runnerFactory = A.Fake<IBoostTestRunnerFactory>();
            A.CallTo(() => runnerFactory.GetRunner(A<string>._, A<BoostTestRunnerFactoryOptions>._)).Returns(runner);
            
            var executor = new BoostTestExecutor(runnerFactory, new StubBoostTestDiscovererFactory(this), DummyVSProvider.Default);

            executor.RunTests(
                new string[] { DefaultSource },
                this.RunContext,
                this.FrameworkHandle
            );

            Assert.That(this.FrameworkHandle.Results.Count, Is.EqualTo(1));
            
            var result = this.FrameworkHandle.Results.First();
            
            // NOTE Given that there is no exact definition as to how a test should be marked (skipped/failed)
            //      in such scenarios, we are asserting on what we are not expecting rather than what we expect

            Assert.That(result.Outcome, Is.Not.EqualTo(TestOutcome.None));
            Assert.That(result.Outcome, Is.Not.EqualTo(TestOutcome.Passed));
        }

        /// <summary>
        /// Assert that: If a Boost.Test execution fails to produce a result file, all such tests are marked as failed
        /// </summary>
        [Test]
        public void MissingReportFile()
        {
            this.TestResourceProvider = CreateDefaultResourceFactory(
                "BoostTestAdapterNunit.Resources.ReportsLogs.Empty.sample.test.log.xml",
                null
            );

            this.Executor.RunTests(
               new string[] { DefaultSource },
                this.RunContext,
                this.FrameworkHandle
            );
            
            Assert.That(this.FrameworkHandle.Results.Count, Is.EqualTo(1));

            var result = this.FrameworkHandle.Results.First();
            
            Assert.That(result.Outcome, Is.EqualTo(TestOutcome.Failed));
        }

        #endregion Tests
    }
}